原码反码和补码

原码

上面我们说了实际上所有的数字都是使用0和1这样的二进制数来进行表示的 但是这样仅仅只能保存正数 那么负数怎么办呢

比如现在一共有4个bit位来保存我们的数据 为了表示正负 我们可以让第一个bit位专门来保存符号 这样 我们这4个bit位能够表示的数据范围就是:
	
	> 最小: 1111 => - (22+21+2^0) => -7
	> 最大: 0111 => + (22+21+2^0) => +7 => 7

虽然原码表示简单 但是原码在做加减法的时候 很麻烦! 以4bit位为例:

	1+(-1) = 0001 + 1001 = 怎么让计算机去计算? (虽然我们知道该去怎么算 但是计算机不知道 计算机顶多知道1+1需要进位!)

我们得创造一种更好的表示方式 于是我们引入了反码:

反码

正数的反码是其本身 负数的反码是在其原码的基础上 符号位不变 其余各个位取反

经过上面的定义 我们再来进行加减法:

	1+(-1) = 0001 + 1110 = 1111 => -0 (直接相加 这样就简单多了!)

思考: 1111代表-0 0000代表+0 在我们实数的范围内 0有正负之分吗？

0既不是正数也不是负数 那么显然这样的表示依然不够合理

补码

根据上面的问题 我们引入了最终的解决方案 那就是补码 定义如下:

正数的补码就是其本身(不变!) 负数的补码是在其原码的基础上 符号位不变 其余各位取反 最后+1 (即在反码的基础上+1)

其实现在就已经能够想通了 -0其实已经被消除了! 我们再来看上面的运算:
	
	1+(-1) = 0001 + 1111 = (1)0000 => +0 (现在无论你怎么算 也不会有-0了!)

所以现在 4bit位能够表示的范围是: -8~+7(C使用的就是补码!)