指针函数与函数指针

我们的函数可以返回一个指针类型的结果 这种函数我们就称为函数指针

                    #include <stdio.h>

                    int * test(int *a) { // 函数的返回值类型是int *指针类型的
                        return a;
                    }

                    int main() {
                        int a = 10;
                        int *p = test(&a); // 使用指针去接收函数的返回值
                        printf("%d", *p);
                        printf("%d", *test(&a)); // 当然也可以直接把间接运算符在函数调用前面表示直接对返回的地址取地址上的值
                    }

不过要注意指针函数不要尝试去返回一个局部变量的地址:

                    #include <stdio.h>

                    int * test(int a) {
                        int i = a;
                        return &i; // 返回局部变量i的地址
                    }

                    int main() {
                        int *p = test(20); // 连续调用两次test函数
                        test(30);

                        printf("%d", *p); // 最后结果并不是我们想的那样
                    }

                    30
                    进程已结束,退出代码0

为什么会这样呢? 还记得我们前面说的吗? 函数一旦返回 那么其中的局部变量就会全部销毁了 至于这段内存之后又会被怎么去使用 我们也就不得而知了

    局部变量其实是存放在栈中的 如果前面的选学部分听了之后 你就知道为什么这里得到的是第二次的30了 因为第二次调用的栈帧入栈后就覆盖了这段内存
    又因为是同一个函数所以栈帧结构是一样的 最后在同样的位置就存放了新的30这个值

我们接着来看函数指针 实际上指针除了指向一个变量之外 也可以指向一个函数 当然函数指针本身还是一个指针 所以依然是用变量表示
但是它代表的是一个函数地址(编译时系统会为函数代码分配一段存储空间 这段存储空间的首地址称为在这个函数的地址)

我们来看看如何定义:

                    $include <stdio.h>

                    int sum(int a, int b) {
                        return a + b;
                    }

                    int main() {
                        // 类型(*指针变量名称)(函数参数...) // 注意一定要把*和指针变量名称括起来 不然优先级不够
                        int (*p)(int, int) = sum;
                        printf("%p", p);
                    }

这样我们就拿到了函数的地址 既然拿到函数的地址 那么我们就可以通过函数的指针调用这个函数了:

                    #include <stdio.h>

                    int sum(int a, int b) {
                        return a + b;
                    }

                    int main() {
                        int (*p)(int, int) = sum;
                        int result = (*p)(1, 2); // 就像我们正常使用函数那样 (*p)表示这个函数 后面依然是在小括号里面填上实参
                        int result = p(1, 2); // 当然也可以直接写函数指针变量名称 效果一样(咋感觉就是给函数换了个名呢)
                        printf();
                    }

有了函数指针 我们就可以编写函数回调了(所谓回调就让别人去调用我们提供的函数 而不是我们主动来调别人的函数)
比如现在我们定义了一个函数 不过这个函数需要参数通过一个处理的逻辑才能正常运行:

                    int sum2(int (*p)(int, int), int a, int b) { // 将函数指针作为参数传入
                        // 函数回调
                        return p(a, b); // 就像你进了公司然后花钱请别人帮你写代码 工资咱们五五开 属于是直接让比如帮你实现
                    }

于是我们就还要给他一个其他函数的地址:

                    #include <studio.h>

                    int sum(int (*p)(int, int), int a, int b) {
                        return p(a, b);
                    }

                    int sumImpl(int a, int b) { // 这个函数实现了 a+b
                        return a + b;
                    }

                    int main() {
                        int (*p)(int, int) = sumImpl; // 拿到实现那个函数的地址
                        printf("%d", sum(p, 10, 20)); 
                    }

当然 函数指针也可以保存一组函数的地址 成为函数指针数组 但是这里就不多说了 相信各位已经快顶不住了吧 