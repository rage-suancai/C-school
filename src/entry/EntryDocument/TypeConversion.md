类型转换

一种类型的数据可以转换为其他类型的数据 这种操作我们称为类型转换 类型转换分为"自动类型转换"和"强制类型转换"
比如我们现在希望将一个short类型的数据类型转换为int类型的数据:

					#include <stdio.h>

					int main() {
				
						short s = 10;
						int i = s; // 直接将s的值传递给i即可 但是注意此时s和i的类型不同
					}

这里其实就是一种自动类型转换 自动类型转换就是编译器隐式地进行的数据类型转换 这种转换不需要我们做什么 我们直接写就行 会自动进行转换操作
				
					float a = 3; // 包括这里我们给的明明是一个int整数3 但是却可以赋值给float类型 说明也是进行了自动类型转换

如果我们使用一个比转换的类型最大值都还要大的值进行类型转换 比如:

					#include <stdio.h>

					int main() {
						int a = 511;
						char b = a; // 最大127
						printf("%d". b);
					}	

					-1
					进程已结束,退出代码0

很明显char类型是无法容纳大于127的数据的 因为只占一个字节 而int占4个字节 如果需要进行转换 那么就只能丢掉前面的就只保留char所需的那几位了 所以这里得到的就是-1:

	> 511 = int -> 00000000 00000000 00000001 11111111
	> char -> 11111111 -> -1

我们也可以将整数和小数类型的数据进行互相转换:
				
					#include <stdio.h>

					int main() {
						int a = 99;
						double d = a;
						printf("%f", d);
					}

					99.000000
				

不过这里需要注意的是 小数类型在转换回整数类型时 会丢失小数部分(注意: 不是四舍五入 是直接丢失小数):
				
					#include <stdio.h>

					int main() {
						double a = 3.14;
						int b = a; // 这里编译器还提示了黄标 我们可以通过之后讲到的强制类型转换来处理
						printf("%d", b);
					}

					3
					进程已结束,退出代码0

除了赋值操作可以进行自动类型转换之外 在运算中也会进行自动类型转换 比如:

					#include <stdio.h>

					int main() {
						float a = 2;
						int b = 3;
						double c = b / a; // "/"是除以的意思 也就是我们数学中的除法运算 这里表示a除以b
						printf("%f", c);
					}

					1.500000
					进程已结束,退出代码0

可以看到 这里得到的结果是小数1.5 但是参与运算的既有整数类型 又有浮点类型 结果为什么确定为浮点类型了呢? 这显然是由于类型转换导致的 那么规则是什么呢?

					char ------
							
								------> int ------> unsgined int ------> long ------> double
																					|
					short ------															|
																				  float

	> 不同的类型优先级不同(根据长度而定)
	> char和short类型在参与运算时一律转换为int再进行运算
	> 浮点类型默认按双精度进行计算 所以就算有float类型 也会转换为double类型参与计算
	> 当有一个更高优先级的类型和一个低优先级的类型同时参与运算时 统一转换为高优先级运算 比如int和long参与运算
	  那么int转换为long再算 所以结果也是long类型 int和double参与运算 那么先把int转换为double再算

我们接着来看看强制类型转换 我们可以为手动去指定类型 强制类型转换格式如下:

					(强制转换类型) 变量,常量或表达式

比如:
				
					#include <stdio.h>

					int main() {
						int a = (int) 2.5; // 2.5是一个double类型的值 但是我们可以强制转换为int类型赋值给a 强制转换之后小数部分丢失
						printf("%d", a);
					}

我们也可以对一个算式的结果进行类型转换:

					#include <stdio.h>

					int main() {
						double a = 3.14;
						int b = (int)(a + 2.8); // 注意得括起来表示对整个算式的结果进行类型转换(括号跟数学中挺像 也是提示优先级使用的 我们会再运算符部分详细讲解) 不然强制类型转换只对其之后紧跟着的变量生效
						printf("%d", b);
					}

在我们需要得到两个int相除之后带小数的结果时 强制类型转换就显得很有用:

					#include <stdio.h>

					int main() {
						int a = 10, b = 4;
						double c = a / b; // 不进行任何的类型转换 int除以int结果仍然是int 导致小数丢失
						double d = (double) a / b; // 对a进行强制类型转换 现在的double和int计算 根据上面自动类型转换规则 后面的int自动转换为double 结果也是double了 这样就是正确的结果
						printf("不进行类型转换: %f, 进行类型转换: %f", c, d);
					}

合理地使用强制类型转换 能够解决我们很多情况下的计算问题