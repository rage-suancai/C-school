实战: 冒泡排序算法

现在有一个int数组 但是数组内的数据是打乱的 现在请你通过C语言 实现将数组中的数据按从小到大的顺序进行排列:

                    #include <stdio.h>

                    int main() {
                        int arr[10] = {3, 5, 7, 2, 9, 0, 6, 1, 8, 4};  // 乱序的
                        // 请编写代码对以上数组进行排序
                    }

这里我们使用冒泡排序算法来实现 此算法的核心思想是:

    > 假设数组长度为N
    > 进行N轮循环 每轮循环都选出一个最大的数放到后面
    > 每次循环中 从第一个数开始 让其与后面的数两两比较 如果更大 就交换位置 如果更小 就不动

动画演示: https://visualgo.net/zh/sorting?slide=2-2

------------------------------------------------------------------------------------------------------------------

实战: 斐波那契数列解法其二

学习了数组， 我们来看看如何利用数组来计算斐波那契数列 这里采用动态规划的思想

    动态规划算法通常用于求解具有某种最优性质的问题 在这类问题中 可能会有许多可行解 每一个解都对应于一个值 我们希望找到具有最优值的解
    动态规划算法与分治法类似 其基本思想也是将待求解问题分解成若干个子问题 先求解子问题 然后从这些子问题的解得到原问题的解

我们可以在一开始创建一个数组 然后从最开始的条件不断向后推导 从斐波那契数列的规律我们可以得知:

    > fib[i] = fib[i - 1] + fib[i - 2] (这里fib代表斐波那契数列)

得到这样的一个关系(递推方程)就好办了 我们要求解数列第i个位置上的数 只需要知道i - 1和i - 2的值即可
这样 一个大问题 就分成了两个小问题 比如: 现在我们要求解斐波那契数列的第5个元素

    > fib[4] = fib[3] + fib[2]现在我们只需要知道fib[3]和fib[2]即可 那么我们接着来看
    > fib[3] = fib[2] + fib[1]以及fib[2] = fib[1] + fib[0]
    > 由于fib[0]和fib[1]我们已经明确知道是1了 那么现在问题其实已经有结果了 把这些小问题的结果组合起来不就能得到原来大问题的结果了吗?

现在请你设计一个C语言程序 利用动态规划的思想解决斐波那契数列问题

------------------------------------------------------------------------------------------------------------------

实战: 打家劫舍

我们继续通过一道简单的算法题来强化动态规划思想

来源: 力扣(LeetCode) No.198 打家劫舍: https://leetcode.cn/problems/house-robber/

    你是一个专业的小偷 计划偷窃沿街的房屋 每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统
    如果两间相邻的房屋在同一晚上被小偷闯入 系统会自动报警 给定一个代表每个房屋存放金额的非负整数数组 计算你不触动警报装置的情况下 一夜之内能够偷窃到的最高金额

示例 1:

    输入：[1,2,3,1]
    输出：4
    解释：偷窃 1 号房屋 (金额 = 1) 然后偷窃 3 号房屋 (金额 = 3)
    偷窃到的最高金额 = 1 + 3 = 4 

示例 2:

    输入: [2,7,9,3,1]
    输出: 12
    解释: 偷窃 1 号房屋 (金额 = 2) 偷窃 3 号房屋 (金额 = 9) 接着偷窃 5 号房屋 (金额 = 1)
    偷窃到的最高金额 = 2 + 9 + 1 = 12 

                    [2] [7] [9] [3] [1]

这道题我们也可以很轻松地按照上面的动态规划思路来处理 首先我们可以将问题分为子问题 比如现在有[2,7,9,3,1]五个房屋 
这个问题看起来比较复杂 我们不妨先将大问题先简化成小问题 我们来看看只有N个房屋的情况

    > 假设现在只有[2]这一个房屋 那么很明显 我可以直接去偷一号房 得到2块钱 所以当有一个房子时最大能偷到2块钱

    > 假设现在有[2, 7]这两个房屋，那么很明显 我可以直接去偷二号房，得到7块钱，所以当有两个房子时最大能偷到7块钱

    > 假设现在只有[2, 7, 9]这三个房屋 我们就要来看看了 是先偷一号房再偷三号房好 还是只偷二号房好 根据前面的结论 如果我们偷了一号房 那么就可以继续偷三号房 
      并且得到的钱就是从一号房过来的钱+三号房的钱 也就是2+9块钱 但是如果只偷二号房的话 那么就只能得到7块钱
      所以 三号房能够偷到的最大金额有以下关系(dp是我们求出的第i个房屋的最大偷钱数量 value表示房屋价值 max表示取括号中取最大的一个)

        > dp[i] = max(dp[i - 1], dp[i - 2] + value[i]) -> 递推方程已得到

    > 这样就不难求出: dp[2] = max(dp[1], dp[0] + value[i]) = dp[2] = max(7, 2 + 9) = dp[2] = 11 所以有三个房屋时最大的金额是11块钱

    > 所以 实际上我们只需要关心前面计算出来的盗窃最大值即可 而不需要关心前面到底是怎么在偷

    > 我们以同样的方式来计算四个房屋[2, 7, 9, 3]的情况:

        > dp[3] = max(dp[2], dp[1] + value[3]) = dp[3] = max(11, 7 + 3) = dp[3] = 11

    > 所以 当有四个房屋时 我们依然采用先偷一后偷三的方案 不去偷四号 得到最大价值11块钱

好了 现在思路已经出来了 我们直接上算法吧 现在请你实现下面的C语言程序:

                    #include <stdio.h>

                    int main() {
                        int arr[] = {2,7,9,3,1}, size = 5, result;

                        // 请补充程序

                        printf("%d", result);
                    }

建议各位小伙伴学习了函数和指针之后再回来看看 这里暂时可以跳过

                    int max(int a, int b) {
                        return a > b ? a : b;
                    }

                    int rob(int* nums, int numsSize){
                        if(numsSize == 0) return 0;
                        if(numsSize == 1) return nums[0];
                        if(numsSize == 2) return max(nums[1], nums[0]);

                        int dp[numsSize];
                        dp[0] = nums[0];
                        dp[1] = max(nums[1], nums[0]);

                        for (int i = 2; i < numsSize; ++i) {
                            dp[i] = max(dp[i - 1], dp[i - 2] + nums[i]);
                        }

                        return dp[numsSize - 1];
                    }