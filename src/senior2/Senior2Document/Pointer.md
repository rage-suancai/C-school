指针

指针可以说是整个C语言中最难以理解的部分了 不过其实说简单也简单 你会发现也并没有想象中的那么难
你与它的距离可能只差了那么一些基础知识 这一部分都会及时进行补充的

什么是指针

还记得我们在上一个部分谈到的通过函数交换两个变量的值吗?

                    #include <stdio.h>

                    void swap(int, int);

                    int main() {
                        int a = 10, b = 20;
                        swap(a, b);
                        printf("a=%d, b=%d", a, b); // 最后会得到什么结果?
                    }

                    void swap(int a, int b) {
                        int temp = a; // 这里对a和b的值进行交换
                        a = b;
                        b = temp;
                    }

实际上这种写法是错误的 因为交换的并非是真正的a和b 而是函数中的局部变量 那么有没有办法能够直接对函数外部的变量进行操作呢? 这就需要指针的帮助了

我们知道 程序中使用的变量实际上都在内存中创建的 每个变量都会被保存在内存的某一个位置上(具体在哪个位置是由系统分配的)
就像我们最终会在这个世界上的某个角落安家一样 所有的变量在对应的内存位置是都有一个地址(地址是独一无二的)
而我们可以通过这个地址寻找到这个变量本体 比如int占据4字节 因此int类型变量的地址就是这4个字节的起始地址 后面32个bit位全部是用于存放此变量的值的

                                   0x0000000                                      0xFFFFFFFF
                    [                                       [int a]                                      ]
                             一段4G的内存空间       int在内存中占据4个字节的空间       
                                                       地址是: 0x00FAFAFA

这里的0x是十六进制的表示形式(10-15用字母A-F表示) 如果我们能够知道变量的内存地址
那么无论身在何处 都可以通过地址找到这个变量了 而指针的作用 就是专门用来保存这个内存地址的

我们来看看如何创建一个指针变量用于保存变量的内存地址:

                    #include <stdio.h>

                    int main() {
                        int a = 10
                        // 指针类型需要与变量的类型相同 且后面需要添加一个*符号(注意这里不是乘法运算)表示是对于类型的指针
                        int *p = &a; // 这里的&并不是进行按位与运算 而是取地址操作 也就是拿到变量a的地址
                        printf("a在内存中的地址为: %p", p); // 地址使用%p表示
                    }

                    a在内存中的地址为: 0061FF08
                    进程已结束,退出代码0

可以看到 我们通过取地址操作& 将变量a的地址保存到了一个地址变量p中

拿到指针之后 我们可以很轻松获取指针地址上的值:

                    #include <stdio.h>

                    int main() {
                        int a = 666;
                        int *p = &a;
                        printf("内存&p上存储的值为: %d", p, *p); // 我们可以在指针变量前添加一个*号(间接运算符 也可以叫做解引用运算符)来获取对应地址存储的值
                    }

                    内存0061FF08上存储的值为: 888
                    进程已结束,退出代码0

注意这里访问指针所指向的地址的值时 是根据类型来获取的 比如int类型占据4个字节 那么就读取地址后面4个字节的内容作为一个int值
如果指针是cahr类型的 那么就只读取地址后面1个字节作为char类型的值

同样的 我们也可以直接像这样去修改对应地址存放的值:

                    #include <stdio.h>

                    int main() {
                        int a = 666;
                        int *p = &a;

                        *p = 999; // 通过*来访问对应地址的值 并通过赋值运算符对其进行修改

                        printf("a的值为: %d", a);
                    }

                    a的值为: 999
                    进程已结束,退出代码0

实际上拿到一个变量的地址之后 我们完全不需要再使用这个变量 而是可以通过它的指针来对其进行各种修改 因此 现在我们想要实现对两个变量的值进行交换的函数就很简单了:

                    #include <stdio.h>

                    // 这里是两个指针类型的形参 其值为实参传入的地址
                    // 虽然依然是值传递 但是这里传递的可是地址啊
                    // 只要知道地址改变量不是轻轻松松?
                    void swap(int *a, int *b) {

                        int tmp = *a; // 先暂存一下变量a地址上的值
                        *a = *b; // 将变量b地址上的值赋值给变量a对应的位置
                        *b = tmp; // 最后将a的值赋值给b对应位置 OK 这样就成功交换两个变量的值了

                    }

                    int main() {
                        int a = 10, b = 20;
                        swap(&a, &b); // 只需要把a和b的内存地址给过去就行了 这里取一下地址
                        printf("a = %d, b = %d", a, b);
                    }

                    a = 20, b = 10;
                    进程已结束,退出代码0

通过地址操作 我们就轻松实现了使用函数交换两个变量的值了

了解了指针的相关操作之后 我们再来看看scanf函数 实际上就很好理解了:

                    $include <stdio.h>

                    int main() {
                        int a;
                        scanf("%d", &a); // 这里就是取地址 我们需要告诉scanf函数变量的地址 这样它才能通过指针访问变量的内存地址 对我们变量的值进行修改 这也是为什么scanf里面的变量(除数组外)前面都要进行一个取地址操作
                        printf("%d", a);
                    }

当然 和变量一样 要是咱们不给指针变量赋初始值的话 就不知指哪里了 因为指针变量也是变量 存放的其他变量的地址值也在内存中保存 如果不给初始值 那么存放别人地址的这块内存可能在其他地方使用过 
这样就不知道初始值是多少了(那么指向的地址可能是一个很危险的地址 随意使用可能会导致出现严重错误) 所以一定要记得给个初始值或是将其设定为NULL 表示野指针 不指向任何内容

                    #include <stdio.h>

                    int main() {
                        int *a = NULL;
                    }

我们接着来看看const类型的指针 这种指针比较特殊:

                    #include <stdio.h>

                    int main() {
                        int a = 9, b = 10;
                        const int *p = &a;
                        *p = 20; // 这里直接报错 因为被const标记的指针 所指地址上的值不允许发生修改
                        p = &b; // 但是指针指向的地址是可以发生改变的
                    }

我们再来看另一种情况:

                    #include <stdio.h>

                    int main() {
                        int a = 9, b = 10;
                        int *const p = &a; // const关键字被放在了类后面
                        *p = 20; // 允许修改所指地址上的值
                        p = &b; // 但是不允许修改指针存储的地址值 其实就是反过来了
                    }

当然也可以双管齐下:

                    #include <stdio.h>

                    int main() {
                        int a = 9, b = 10;
                        const int * cosnt p = &a;
                        *p = 20; // 两个都直接报错 都不让改了
                        p = &b;
                    }